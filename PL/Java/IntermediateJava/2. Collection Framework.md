> Java에서 제공하는 Collection Framework 정리
# Java의 자료구조 지원
컴퓨터 공학에서 여러 데이터에 대한 집합과 그에 대한 관리 및 처리 기법 등 다양한 방식에 의해 데이터 집합을 처리하는 객체 혹은 알고리즘을 **자료구조**라고 한다.

Java에서는 이미 오래전부터 검증되어온 배열을 기본 데이터 타입과 함께 제공하고 있으며, 이를 기반으로 하여 다양한 알고리즘이 적용되거나 관리 기법들이 반영된 **자료구조** 객체들을 제공한다.

크게 `Map`, `List`, `Set` 등의 **자료구조** 객체 및 관련 메소드를 제공하며, 이 뿐만 아니라 보다 다양한 **자료구조** 객체들을 `java.util.* 패키지 내에 구성하여 제공하고 있다.

이러한 `java.util.*` 내에 포함된 **자료구조** 객체들을 **Collection Framework**라고 칭한다.

# Array
**배열**이라고도 하며 Java 에서 기본 데이터 타입 (`int`, `float`, `long` 등)과 같이 기본적으로 제공하는 문법으로 아래와 같이 선언하여 사용할 수 있다.

```java
int[] intArray = new int[5];
```

위와 같이 `[]` 기호를 사용하여 **배열**을 구성할 수 있으며, 기호 내의 숫자를 입력하여 **배열**의 초기 크기를 지정할 수 있다.

## 배열의 메모리 관리
**배열**의 경우 아래의 방식으로 다수의 데이터를 연속된 메모리 주소 영역에 할당하여 관리한다.

![](Pasted%20image%2020241030002203.png)

위와 같이 **배열**의 시작 `index`를 기준으로 주어진 데이터 타입의 크기만큼, 주어진 배열의 크기만큼 할당하여 구성되며, 이에 따라 하나의 참조 주소(시작 값)을 기준으로 **배열** 내 전체 데이터를 관리 할 수 있게 된다.

이는, 아래와 같이 대단위의 데이터를 지닌 **배열**일 지라도 `index`를 기반으로 한 조회 및 데이터 수정 등의 경우 단 1회의 요청으로 **배열** 내 모든 데이터에 접근이 가능하다는 것을 뜻한다.
```java
int[] intArray = new int[555];
...
System.out.println("index 233 == " + intArray[233]);
```

위의 경우, 233번 `index`에 해당하는 값을 찾기 위해 233번의 순회를 돌 필요 없이 `index` 및 주어진 데이터 타입 기준으로 단순 계산된 값으로 곧바로 해당 주소를 특정 할 수 있다.
- `배열의 참조 주소값 = 시작 index 주소 + (데이터 타입 크기 x index)`

Java에서 제공하는 **Collection Framework**의 대부분의 객체들은 이러한 **배열**을 기본으로 하여 구성되었다.

> [!NOTE]
> **배열의 값 검색**
> 
> **배열**의 `index`를 통한 검색의 경우, 앞서 말한대로, 단순 1회 요청만으로 어느 위치의 데이터든 한번에 조회가 가능하나, 이는 `index`를 기준으로 하였을 때의 경우이며, 실제 참조 주소 내 존재하는 값을 기준으로 할 경우에는 최대 **배열**의 크기만큼 순회를 돌며 실제 값을 찾아야 한다.

> [!NOTE]
> **Big O 표기법**
> 
> 프로그래밍 분야에서 특정 데이터를 탐색할 때 사용되는 다양한 방식 및 알고리즘 등에 대한 성능 측정 지표로 **Big O** 표기법이 존재하며, 주로 아래와 같이 `O` 문자 및 수식을 통해 특정 방식에 대한 추세를 시각화 하거나 표현한다.
> 
> ![](Pasted%20image%2020241103214612.png)
> 
> - **Array**의 경우 **Index**를 통한 데이터 탐색은 항상 1회만에 탐색이 가능하기에 `O(1)`이며, 값 탐색 시에는 최대 **Array**의 데이터 수만큼의 탐색이 필요하기에 `O(n)`으로 표기한다.

## 배열의 한계점
Java에서 기본적으로 제공하는 요소인 **배열**의 경우 `index` 기반 조회를 기준으로 할 때, 무척이나 효율적인 알고리즘을 지니고 있다. 하지만, 이러한 **배열**도 만능은 아니며, 당장에 값을 기준으로한 검색의 경우 `O(n)`의 횟수가 걸리며, 이외에도 아래와 같은 한계점들이 존재한다.

### 신규 데이터 삽입의 한계
초기값을 주입한 배열의 경우 특정 위치에 신규 값을 주입할 경우 크게 아래와 같이 세 경우로 나뉘게 된다.

**1. 첫 번째 index에 삽입**
첫 번째 `index`에 삽입할 경우, 기존 값들을 현재 `index` + 1 만큼의 위치로 옮겨야 하며, 이에 따라 첫 번째 `index` 이후 **배열**의 전체 길이만큼 수정 작업이 필요하게 된다. 이에 따라 `O(n)`만큼의 작업이 진행되게 된다.

**2. 중간 index에 삽입**
중간에 위치한 `index`에 삽입할 경우, 해당 `index` 이전의 값들은 옮길 필요가 없으나, 이 후 `index`들은 마찬가지로 `+1`만큼 옮겨야 하며, 정중앙 `index`를 기준으로 `O(2/n) := O(n)` 만큼의 작업이 진행되게 된다.

**3. 마지막 index에 삽입**
**배열**의 마지막 부분에 추가 값을 삽입할 경우, 이전 모든 `index`의 값들은 수정될 필요가 없기에 
`O(1)`의 작업이 진행되게 된다.

각 `index` 위치에 따라 `O(n) ~ O(1)` 까지 다양한 범위의 작업 수행의 차이가 발생하며, 이는 각 삽입 작업이 일반적인 `index` 조회보다 최대 N배 이상 느려질 수 있다는 것을 뜻하게 된다.

### 배열의 고정된 크기
데이터 삽입 문제 뿐만 아니라, **배열**은 근본적으로 생성 시점에 메모리에 할당되는 크기가 정해지며, 이에 따라 데이터 삽입의 경우에도, 최대 삽입 가능 크기가 초기 설정된 값을 넘지 못하게 된다.

이러한 점에 따라, **배열** 생성 시점에 매우 큰 크기를 미리 할당한다 하여도, 그만큼의 메모리가 낭비되는 문제가 발생하게 된다.

> [!NOTE]
> 
> 결과적으로 위와 같은 **배열**의 한계점들이 존재하기에, 동적으로 크기를 구성하거나 데이터 삽입 시 보다 효율적인 작업 알고리즘을 수행하는 다양한 **자료 구조**들이 등장하게 되었으며, Java에서는 이러한 다양한 **자료 구조**들을 **Collection Framework**로 묶어서 표현한다.

