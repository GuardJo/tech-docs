> 해시 알고리즘 정리

# 해시 알고리즘
다량의 데이터들을 관리하는 **자료구조**의 특성상 데이터가 많아질 수록, 특정 데이터 값을 찾기 위해서는 `O(n)`의 성능을 기준으로 할 경우, 기하급수적으로 조회 성능이 떨어지게 된다.

하지만 **Hash Algoritm**을 통해 이러한 조회 성능들을 `O(1)`에 가깝게 향상시킬 수 있으며, Java의 **Collection Framework**에서 제공하는 `HashSet`, `LinkedHashSet` 등의 **자료구조** 구현체들이 **Hash Algorithm**을 활용하여 성능을 최적화하여 제공하고 있다.

## Hash
앞선 **배열**과 같은 경우 `index`를 기반으로 한 조회 시에는 `O(1)`의 성능을 발휘한다. 하지만 데이터의 값을 기준으로 조회 할 때에는 **배열** 내 데이터를 순회하면서 값을 확인해야 하기에 `O(n)`로 성능이 낮아지게 된다.

해당 관점에서 만약 데이터 값을 `index`처럼 활용하게 된다면 `O(1)`의 성능을 기대할 수 있을 것이며, 이러한 시나리오를 기반으로 데이터 값을 특정 계산을 통해 고유한 `index`값으로 변환하여 `index` 와 같은 조회 성능을 발휘하도록 하는 것이 **Hash Algorithm**의 핵심 기능이며, 이렇게 변환된 고정 길이의 값을 **Hash**라고 하며 이를 `index`로 활용한다.

> [!NOTE]
> **Hash Table**
> 
> 위와 같이 **Hash**를 `index` 값으로 하여 빠른 데이터 조회를 위한 자료구조를 **Hash Table**이라고 하며, 보통 제한된 크기 내에서 **Hash Function**을 통해 **Hash**로 변환된 데이터 값을 해당 `index`에 삽입하여 데이터를 관리한다.

## Hash Function
입력되는 데이터 값을 기준으로 하여 `Hash`를 구성하는 데에는 다양한 계산 방식들이 존재하며, 이를 **Hash Function**이라고 한다.
주로, **modulo 연산(나머지연산)** 을 기반으로 하여 제각각의 크기를 지닌 데이터 값을 고정된 값으로 치환하도록 하며, 이렇게 치환된 값을 `Hash`로 활용하게 된다.

> [!NOTE]
> **Hash Function**에 따라 다양한 **Hash Algorithm**들이 존재하며, 결과로 반환되는 고정 길이의 값인 **Hash**가 얼마나 불규칙적인지 여부와, 또한 서로 다른 입력값을 통해 동일한 **Hash** 값이 나올 확률이 적은 지가 중요하다.

# 해시 충돌
`Hash Collision`이라고 부르는 해당 현상은, **Hash Function**에 의해 특정 고정된 크기의 값으로 변환되는 **Hash** 를 `index`로 하여 데이터를 저장할 때, 서로 다른 값이 동일한 **Hash** 값으로 변환되어 동일한 `index` 내에 저장되게 되는 현상을 뜻한다.

각 **Hash Algorithm**마다 발생 빈도는 다르지만, 실무에 쓰이는 대부분의 **Hash Algorithm**에서는 낮은 확률로 발생하는 현상이다.

이러한 **해시 충돌** 현상이 발생할 경우, 적재된 데이터가 조회에 대한 신뢰성이 떨어지므로, 실제 **Hash Algorithm**들은 아래의 방식들을 통해 **해시 충돌**을 해결한다.

## Chaining 기법
![](images/Pasted%20image%2020241129234528.png)
일부 데이터 주입 간 **Hash Collision**이 발생한 경우, 동일한 `index` 내에 `LinkedList` 형태로 충돌된 데이터 값들을 적재해 나가는 방식이다.

해당 방식을 통해, **Hash Collision**이 발생하더라도 다른 저장 공간을 탐색할 필요 없이, 해당 `index` 내 `LinkedList`에 데이터를 추가하기만 하면 되기에 비교적 간단한 기능으로 동작할 수 있다.

하지만 한 `index` 내 `LinkedList`의 크기가 커질 수록 `O(n)` 의 성능을 보이게 되며, **Hash Collision**이 쌓일 수록 조회 성능이 저하되게 된다.

> [!NOTE]
> Java 에서는 **Chaining** 기법을 통해 **Hash Collision**을 제어하고 있으며, 내부적으로 특정 개수 미만인 경우에는 `LinkedList`를 기반으로 하되, 특정 개수 이상에 도달할 경우 `TreeSet`을 기반으로 관리한다.

## Open Address 기법
**Hash Collision**이 발생했을 때, **Hash Table** 내 비어 있는 다른 `index`를 찾아 빈 공간에 충돌된 데이터 값을 적재해 나가는 방식이다.

이 때 비어 있는 `index`를 찾는 방식에 따라 아래와 같은 탐색 기법들이 존재한다.

### 선형 탐사 방식
![](images/Pasted%20image%2020241129235316.png)
`Linear Probing`이라고도 하며, 충돌 당시 `index`에서 차례 대로 다음 `index`로 순회를 돌며, 빈 공간이 나오면 데이터를 적재하는 방식이다.

이는, 충돌이 나더라도 빈 `index`에 데이터를 할당 해줌으로써 **Chaining** 기법과 달리, 데이터 조회 시 `O(1)`의 성능을 항시 보장할 수 있다.

하지만, 순차적으로 빈 공간을 찾는 `Linear Probing` 방식의 특정 상 빈 `index`에 할당하기까지의 시간이 더욱 소요되며, **Hash Table** 자체가 가득 찰 경우 더 이상 해결할 수 없는 문제가 존재한다.

> [!NOTE]
> **Clustering 문제**
> 
> **Lienar Probing** 방식의 문제점 중 하나는 **Hash Collision**이 발생할 수록, **Hash Table**내 빈 공간을 소모하게 되며, 이에 따라 결과적으로는 발생 빈도가 올라갈수록 기하급수적으로 성능이 저하되게 된다.

### 이중 해싱
`Double Hashing`이라고도 하며 **Hash Collision** 발생 시 1차적으로 수행된  **Hash Function**과 별개의 **Hash Function**을 사용하여 별도의 빈 `index` 내 데이터를 적재하는 방식이다.

이를 통해 앞서 **Linear Proving** 방식에 비해 빈 `index`탐색에 보다 효율적인 성능을 보일 수 있으며, 이후 이어지는 데이터 적재 간에 **Hash Collision** 가능성도 상대적으로 낮아지게 된다.

하지만, 별도의 **Hash Function**을 추가로 구성해야 함으로써 복잡도가 증가하게 된다.