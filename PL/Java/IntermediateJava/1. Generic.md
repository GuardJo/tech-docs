> Java에서 제공하는 Generic 에 대한 학습 내용 정리

# 다형성에서의 타입 안전성 문제
Java에서는 모든 객체는 별도로 명시하지 않을 경우 `Object` 객체의 하위 객체들이다. 그렇기에 메소드의 인자나 필드의 타입을 `Object` 타입으로 선언할 경우 Java 내 모든 타입의 데이터를 매핑할 수 있게 된다.

## 다형성을 통한 중복 코드 제거
```java
public class IntegerBox {  
    private Integer value;  
  
    public void set(Integer value) {  
        this.value = value;  
    }  
  
    public Integer get() {  
        return this.value;  
    }  
}
...
public class StringBox {  
    private String value;  
  
    public void set(String value) {  
        this.value = value;  
    }  
  
    public String get() {  
        return value;  
    }  
}
...
public class BoxMain {  
    public static void main(String[] args) {  
        IntegerBox integerBox = new IntegerBox();  
        integerBox.set(10);  
        System.out.println(integerBox.get());  
  
        StringBox stringBox = new StringBox();  
        stringBox.set("test");  
        System.out.println(stringBox.get());  
    }  
}
```

만약 위와 같이 Java 내 데이터 타입 별로 위와 같은 객체를 구성해야 할 경우, 데이터 타입의 수만큼 중복 코드가 발생하게 된다.

이를 아래와 같이 `Object` 객체로 구성할 경우 데이터 타입 별로 중복 코드를 지닌 객체들을 구성할 필요 없이 하나의 객체로 모든 데이터 타입을 처리할 수 있게 된다.
```java
public class ObjectBox {  
    private Object value;  
  
    public void set(Object value) {  
        this.value = value;  
    }  
  
    public Object get() {  
        return value;  
    }  
}
...
public class BoxMain {  
    public static void main(String[] args) {  
        ObjectBox integerBox = new ObjectBox();  
        integerBox.set(10);  
  
        Integer integer = (Integer) integerBox.get(); // Required downcasting
        System.out.println(integer);  
  
        ObjectBox stringBox = new ObjectBox();  
        stringBox.set("Hello");  
        String string = (String) stringBox.get(); // Required downcasting
        System.out.println(string);  
    }  
}
```

위와 같이 다형성 메소드로 구성된 **ObjectBox** 객체를 통해 다양한 데이터 타입을 하나의 객체에서 처리할 수 있게 된다.
단, 이 때 메소드를 통해 반환되는 값도 `Object` 타입이기에 각각 원하는 데이터 타입으로 **DownCasting** 작업이 필요하다.

이 때, 만약 아래와 같이 의도치 않은 데이터 타입을 주입할 경우 `ClassCastException`이 발생할 수 있다.
```java
integerBox.set("test");
Intenger number = (Integer) integerBox.get(); // `ClassCastException`
```

이 때문에, `Object` 타입을 통한 다형성 메소드를 통해 중복 코드를 정리하게 되면, 컴파일 시점에서 위와 같은 문제를 식별 할 수 없기에 런타임 환경에서 위와 같은 문제가 발생할 수 있으며, 결국 **타입 안전성**이 떨어지게 된다.
# Generic Class
Java에서는 위의 다형성 및 그에 따른 문제점들을 해결하기 위해 컴파일 시점에 타입을 지정하는 것이 아닌 런타임 시점에 신규 인스턴스 생성 시 타입을 외부에서 주입해줄 수 있도록 지원한다.

```java
public class GenericBox<T> {  
    private T value;  
  
    public void set(T value) {  
        this.value = value;  
    }  
  
    public T get() {  
        return value;  
    }  
}
```

위의 `GenericBox` 객체 구성 시 `<>` 기호 내에 임의의 문자값으로 넣어 해당 타입을 컴파일 시점에 구성하지 않고, 런타임 시점에 주입하도록 하여 아래와 같이 다양한 타입을 동일한 로직에 주입해서 사용할 수 있으며, 이러한 객체를 `Generic Class`라고 한다.

```java
public static void main(String[] args) {  
    GenericBox<Integer> integerBox = new GenericBox<Integer>();  
    integerBox.set(10);  
    // integerBox.set("test"); // 컴파일 오류  
    Integer intValue = integerBox.get();  
    System.out.println(intValue);  
  
    GenericBox<String> stringBox = new GenericBox<String>();  
    stringBox.set("test");  
    // stringBox.set(10); // 컴파일 오류  
    String stringValue = stringBox.get();  
    System.out.println(stringValue);  
}
```

위와 같이 `Generic Class` 인스턴스 생성 시점에 기존 타입 매개변수에 넣을 실제 데이터 타입을 `<>` 기호 내에 주입함으로써 `Generic Class` 내에 위치해 있던 타입 매개변수의 타입을 실제 주어진 데이터타입으로 매핑하여 인스턴스를 생성하게 된다.

이러한 `Generic Class`는 `Object` 객체와는 달리 데이터타입이 인스턴스 생성 시점에 정해져 있기에 정해진 데이터타입만 동작할 수 있기에 컴파일 시점에 다른 데이터 타입을 주입할 수 없게 되며, 이 덕분에 **다형성**과 **타입안전성**을 동시에 만족하는 객체를 구성할 수 있다.

## Type Parameter
```java
public GenericBox<T> {
	private T value;
	...
}
```
`Generic Class` 구성 시 `<>` 기호 내에 변수를 **타입 매개변수 (Type Parameter)** 라고 한다. 이는 마치 메소드에서의 매개변수와 같이 외부에서 주입되는 값이기에 위와 같이 칭한다.
### Type Parameter 명명 관례
`Generic Class`의 **타입 매개변수**는 어떠한 문자 값이든 상관 없이 사용할 수 있으나, 다른 객체명과의 중복 및 가독성 등을 고려하여 아래의 명명 관례를 주로 따르고 있다.

- **E** : Element
- **T** : Type
- **K** : Key
- **V** : Value
- **S**, **U**, **V** : param1, param2, param3 등

> [!NOTE]
> `Generic Class` 구성 시 **타입 매개변수**는 여러 매개변수를 지닌 메소드와 마찬가지로 여러 **타입 매개변수**를 지닐 수 있다.

## Type Argument
```java
GenericBox<Integer> box = new GenericBox<Integer>();
```

또한 위와 같이 `Generic Class` 생성 시 **타입 매개변수**에 주입하는 실제 데이터 타입을 **타입 인자 (Type Argument)** 라고 하며 실제 메소드 호출 시 주입하는 인자와 비슷한 요소이다.

### 타입 추론
`Generic Class` 인스턴스 생성 시에는 `<>` 기호 내에 **타입 매개변수** 값을 주입해주어야하나, 이미 변수 타입 선언 시에 **타입 매개변수**를 명시 했을 경우 인스턴스 생성 시에는 아래와 같이 `<>` 내 **타입 매개변수**를 생략할 수 있다. 

```java
GenericBox<Intenger> integerBox = new GenericBox<>();
```

### Raw Type
`Generic Class` 인스턴스를 생성 할 때에는 **타입 매개변수**에 **타입 인자** 를 주입해주어야 하지만 아래와 같이 주입하지 않아도 컴파일에서 문제가 발생하지 않는다.

```java
GenericBox genericBox = new GenericBox();
genericBox.set(10);
Object value = genericBox.get();
```

이는 Java에서 `Generic Class`가 초기부터 존재하던 개념이 아니기에 `Generic Class` 등장 이전 버전과의 하위 호환성을 위해 `<>` 기호를 생략하여 **타입 인자**를 주입하지 않도록 할 수 있으며, 이러한 `Generic Class`를 `Raw Type`이라고 한다.

이러한 `Raw Type`은 **타입 매개변수**를 암묵적으로 `Object` 타입으로 식별하여 인스턴스를 생성한다.