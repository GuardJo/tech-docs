> Java에서 제공하는 Generic 에 대한 학습 내용 정리

# 다형성에서의 타입 안전성 문제
Java에서는 모든 객체는 별도로 명시하지 않을 경우 `Object` 객체의 하위 객체들이다. 그렇기에 메소드의 인자나 필드의 타입을 `Object` 타입으로 선언할 경우 Java 내 모든 타입의 데이터를 매핑할 수 있게 된다.

## 다형성을 통한 중복 코드 제거
```java
public class IntegerBox {  
    private Integer value;  
  
    public void set(Integer value) {  
        this.value = value;  
    }  
  
    public Integer get() {  
        return this.value;  
    }  
}
...
public class StringBox {  
    private String value;  
  
    public void set(String value) {  
        this.value = value;  
    }  
  
    public String get() {  
        return value;  
    }  
}
...
public class BoxMain {  
    public static void main(String[] args) {  
        IntegerBox integerBox = new IntegerBox();  
        integerBox.set(10);  
        System.out.println(integerBox.get());  
  
        StringBox stringBox = new StringBox();  
        stringBox.set("test");  
        System.out.println(stringBox.get());  
    }  
}
```

만약 위와 같이 Java 내 데이터 타입 별로 위와 같은 객체를 구성해야 할 경우, 데이터 타입의 수만큼 중복 코드가 발생하게 된다.

이를 아래와 같이 `Object` 객체로 구성할 경우 데이터 타입 별로 중복 코드를 지닌 객체들을 구성할 필요 없이 하나의 객체로 모든 데이터 타입을 처리할 수 있게 된다.
```java
public class ObjectBox {  
    private Object value;  
  
    public void set(Object value) {  
        this.value = value;  
    }  
  
    public Object get() {  
        return value;  
    }  
}
...
public class BoxMain {  
    public static void main(String[] args) {  
        ObjectBox integerBox = new ObjectBox();  
        integerBox.set(10);  
  
        Integer integer = (Integer) integerBox.get(); // Required downcasting
        System.out.println(integer);  
  
        ObjectBox stringBox = new ObjectBox();  
        stringBox.set("Hello");  
        String string = (String) stringBox.get(); // Required downcasting
        System.out.println(string);  
    }  
}
```

위와 같이 다형성 메소드로 구성된 **ObjectBox** 객체를 통해 다양한 데이터 타입을 하나의 객체에서 처리할 수 있게 된다.
단, 이 때 메소드를 통해 반환되는 값도 `Object` 타입이기에 각각 원하는 데이터 타입으로 **DownCasting** 작업이 필요하다.

이 때, 만약 아래와 같이 의도치 않은 데이터 타입을 주입할 경우 `ClassCastException`이 발생할 수 있다.
```java
integerBox.set("test");
Intenger number = (Integer) integerBox.get(); // `ClassCastException`
```

이 때문에, `Object` 타입을 통한 다형성 메소드를 통해 중복 코드를 정리하게 되면, 컴파일 시점에서 위와 같은 문제를 식별 할 수 없기에 런타임 환경에서 위와 같은 문제가 발생할 수 있으며, 결국 **타입 안전성**이 떨어지게 된다.
# Generic Class
Java에서는 위의 다형성 및 그에 따른 문제점들을 해결하기 위해 컴파일 시점에 타입을 지정하는 것이 아닌 런타임 시점에 신규 인스턴스 생성 시 타입을 외부에서 주입해줄 수 있도록 지원한다.

```java
public class GenericBox<T> {  
    private T value;  
  
    public void set(T value) {  
        this.value = value;  
    }  
  
    public T get() {  
        return value;  
    }  
}
```

위의 `GenericBox` 객체 구성 시 `<>` 기호 내에 **타입 매개변수**를 구성하여 해당 타입을 컴파일 시점에 구성하지 않고, 런타임 시점에 주입하도록 하여 아래와 같이 다양한 타입을 동일한 로직에 주입해서 사용할 수 있으며, 이러한 객체를 `Generic Class`라고 한다.

> [!NOTE]
> **타입 매개변수**
> 
> `Generic Class` 구성 시 `<>` 기호 내에 변수를 **타입 매개변수** 라고 한다. 이는 마치 메소드에서의 매개변수와 같이 외부에서 주입되는 타입이기에 이렇게 부르며, `Generic Class` 구성 시에 T, O 등 임의의 문자값으로 표시할 수 있다.


```java
public static void main(String[] args) {  
    GenericBox<Integer> integerBox = new GenericBox<Integer>();  
    integerBox.set(10);  
    // integerBox.set("test"); // 컴파일 오류  
    Integer intValue = integerBox.get();  
    System.out.println(intValue);  
  
    GenericBox<String> stringBox = new GenericBox<String>();  
    stringBox.set("test");  
    // stringBox.set(10); // 컴파일 오류  
    String stringValue = stringBox.get();  
    System.out.println(stringValue);  
}
```

위와 같이 `Generic Class` 인스턴스 생성 시점에 기존 타입 매개변수에 넣을 실제 데이터 타입을 `<>` 기호 내에 주입함으로써 `Generic Class` 내에 위치해 있던 타입 매개변수의 타입을 실제 주어진 데이터타입으로 매핑하여 인스턴스를 생성하게 된다.

> [!NOTE]
> **타입 추론**
> 
> `Generic Class` 인스턴스 생성 시에는 `<>` 기호 내에 **타입 매개변수** 값을 주입해주어야하나, 이미 변수 타입 선언 시에 **타입 매개변수**를 명시 했을 경우 인스턴스 생성 시에는 아래와 같이 `<>` 내 **타입 매개변수**를 생략할 수 있다. 
> - `GenericBox<Intenger> integerBox = new GenericBox<>();`

이러한 `Generic Class`는 `Object` 객체와는 달리 데이터타입이 인스턴스 생성 시점에 정해져 있기에 정해진 데이터타입만 동작할 수 있기에 컴파일 시점에 다른 데이터 타입을 주입할 수 없게 되며, 이 덕분에 **다형성**과 **타입안전성**을 동시에 만족하는 객체를 구성할 수 있다.