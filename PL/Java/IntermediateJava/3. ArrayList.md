> Collection Framework 내 자료구조 중 ArrayList 정리

# ArrayList
Java에서 기본적으로 제공하던 **배열**은 생성 시점에 크기가 정해지면, 이후에 크기를 변경할 수 없는 정적 요소이다. 이에 따라 초기 크기를 넘어서는 데이터는 삽입할 수 없는 문제가 있으며, Java에서는 이러한 문제점을 해결하기 위한 다양한 **자료 구조**를 지원한다.

그 중 `ArrayList`는 **배열**을 활용하여 기존 **배열**의 단점인 정적 크기를 해결한 **자료 구조** 로써, 삽입 되는 데이터의 수에 따라 동적으로 크기가 변경된다.
## ArrayList 구조
`ArrayList`는 내부적으로 **배열**을 사용하기에 기본적인 데이터 삽입은 **배열**과 마찬가지로 순차적으로 삽입된다.

```java
ArrayList<String> arrayList = new ArrayList<>();
arrayList.add("first");
arrayList.add("second");
arrayList.add("third");
```

위와 같이 `ArrayList`를 선언해서 사용할 수 있으며, **배열**과 다르게 별도의 크기를 지정하지 않는다.

### 데이터 삽입
`add()`와 같은 데이터 삽입 메소드를 별도로 지원하며, 내부 로직을 보면 아래와 같은 형태로 이루어져 있다.
```java
public class ArrayList<E> {
	private static final int DEFAULT_CAPACITY = 10;
	transient Object[] elementData;
	private int size;
	...
	public boolean add(E e) {  
	    modCount++;  
	    add(e, elementData, size);  
	    return true;  
	}
	...
	private void add(E e, Object[] elementData, int s) {  
	    if (s == elementData.length)  
	        elementData = grow();  
	    elementData[s] = e;  
	    size = s + 1;  
	}
	...
}
```

기본적으로 선언부에서 보이듯이, `Generic Class` 이며 `타입 매개변수` 에 주입된 데이터 타입의 매개변수만을 입력받을 수 있으며, 인자로 들어온 데이터를 내부에 들고 있는 **배열**에 삽입하는 형태이다.

이 때, `ArrayList`에 인스턴스 필드 요소 중 `DEFAULT_CAPACITY`를 통해 초기 **배열**의 크기를 지정해두며, `size`를 통해 삽입되는 데이터 수만큼 해당 필드에 기록하여, 추후 **배열**의 실제 크기에 도달했을 시점을 확인하는 용도로 쓰인다.

### 데이터 저장공간 동적 증가
앞서 `add()` 메소드 호출 시 주입되는 데이터의 수가 초기에 구성된 **배열**의 할당 크기만큼 쌓이게 될 경우, `ArrayList` 는 내부적으로 사용하는 **배열**의 크기를 더욱 크게 재구성하여 사용한다.

```java
public class ArrayList<E> {
	private static final int DEFAULT_CAPACITY = 10;
	transient Object[] elementData;
	private int size;
	...
	private void add(E e, Object[] elementData, int s) {  
	    if (s == elementData.length)  
	        elementData = grow();  
	    elementData[s] = e;  
	    size = s + 1;  
	}
	...
	private Object[] grow() {  
	    return grow(size + 1);  
	}
	...
	// 내부 배열의 크기를 동적으로 증가 시켜서 재구성한다.
	private Object[] grow(int minCapacity) {  
	    int oldCapacity = elementData.length;  
	    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {  
	        int newCapacity = ArraysSupport.newLength(oldCapacity,  
	                minCapacity - oldCapacity, /* minimum growth */  
	                oldCapacity >> 1           /* preferred growth */);  
	        return elementData = Arrays.copyOf(elementData, newCapacity);  
	    } else {  
	        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];  
	    }  
	}
}
```

`ArrayList`는 `add()` 호출 시점에 현재 저장되어 있는 데이터 수와 내부 **배열**의 크기를 비교하여, 최대 크기에 도달 했을 경우, `grow()` 메소드를 호출하게 된다.

`grow()` 메소드는 현재 데이터 수 + 1 만큼 크기값과 초기에 구성된 `DEFAULT_CAPACITY` 를 기반으로 증가된 `Capacity`를 계산하여, 증가된 크기로 **배열**을 신규 구성 후, 기존 데이터를 복제한다.

이를 통해 일반적으로 이전 **배열**보다 1.5배 가량 크기를 키운 **배열**이 구성되게 되며, 최종적으로 내부 **배열**로 참조하여 사용하게 된다.
- 이전 **배열**은 참조가 해제되어 이후 **GC**에 의해 메모리에서 제거된다.

> [!NOTE]
> **배열 구성 시 시프트 연산**
> 
> `ArrayList`에서는 동적으로 **배열**의 크기를 늘리기 위해 신규 **배열** 크기를 계산할 때, 단순 연산이 아닌 `시프트 연산`을 통해 처리되고 있다. 이는, 결과적으로는 기존 **배열**의 `Capacity`를 2로 나눈 것이지만, 매 최대 크기 도달 시 계산이 이루어지는 특성 상 이를 일반 연산자 (`/`) 를 통해 연산하는 것보다,  시프트 연산자 (`>>` , `<<`)를 통해 연산하는 것이 대략 10배 이상 빠르기 때문이다.

> [!NOTE]
> **배열의 최대 크기 도달**
> 
> 위와 같이 `grow()`를 통해 최대 크기를 1.5배 씩 지속적으로 증가시킬 수 있으나, 실제 메모리의 한계 상 실제로는 내부적으로 `SOFT_MAX_ARRAY_LENGTH` 까지만 증가 시킬 수 있다.
> 
> `SOFT_MAX_ARRAY_LENGTH`는 `INTEGER_MAX_VALUE` - 8의 값을 지니는데, 단순 `Integer`의 최대값으로 설정하지 않고, 추가 `offset`이 있는 이유는, **배열**이 단순 값들만 관리하는 것이 아니라, 내부적인 메타데이터들도 일부 존재하고 있으며, 이를 위한 메모리 할당을 위해 8만큼의 공간을 미리 빼둔 것이다.