> Java에서 제공하는 동기화 기법 중 Concurrent Lock 관련 정리

# BLOCKED Thread의 문제점
Java는 **Multi Thread** 환경에서 **동시성 문제**를 해결하기 [`synchronized`](11.%20Synchronized.md) 키워드를 Java 1.0부터 제공하였다. 
```java
// synchronized 예시
public synchronized boolean withdraw(long amount) {
	// Critical Section
}
```
`synchornized` 키워드는 해당 포함된 메소드나 코드 블럭을 실행 할 경우 Java 인스턴스에 내장된 **Monitor Lock** 에 의해 호출 `Thread` 이외의 `Thread`들은 접근 시 `BLOCKED` 상태에 빠지게 된다.

위와 같은 방식 덕분에 Java는 초창기부터 **동시성 문제**를 보다 쉽게 해결할 수 있었으나, `Thread`의 `BLOCKED` 상태에는 아래와 같은 단점이 존재한다.
- `BLOCKED` 상태의 `Thread`는 오로지 **Monitor Lock**을 획득해야만 상태가 변경 될 수 있음
- `BLOCKED` 상태에서 **Monitor Lock**을 획득하는 우선순위는 Java에서 정의하고 있지 않음
- 최악의 경우, 무한대기 상태애 빠질 수 있음

# Concurrent 패키지
`synchronized` 키워드가 존재하는 **Multi Thread** 환경에서 `BLOCKED` 상태의 `Thread` 에 대한 문제점들이 제기됨에 따라 Java에서는 1.5 이후에 **동시성 문제**를 해결할 수 있는 **java.util.concurrent** 패키지를 제공하기 시작했다.

## LockSupport
**java.util.concurrent** 패키지에서는 기존 `BLOCKED` 상태의 `Thread`가 무한대기 하는 등의 문제를 해결하기 위해 **LockSupport**라는 객체를 통해 `Thread`의 상태를 제어하도록 하였다.

**LockSupport**는 크게 아래와 같은 메소드들을 제공하며, 이를 통해 기존 `BLCOKED` 상태로 넘어가던 `Thread`를 제어하여 `Lock`을 관리할 수 있게 되었다.

### park()
```java
private static class LockSupportTask implements Runnable {  
  
    @Override  
    public void run() {  
        Logger.log("Start " + Thread.currentThread().getName());  
        LockSupport.park();  
        Logger.log("isInterrupted = " + Thread.currentThread().isInterrupted());  
        Logger.log("End " + Thread.currentThread().getName());  
    }  
}
```
`park()` 메소드를 호출할 경우 호출한 `Thread`는 즉각 `WAITTING` 상태로 전환되며, 해당 `Thread`는 `BLOCKED` 상태와는 다르게 `interrupt`나 별도 작업을 통해 다시 `RUNNABLE` 상태로 전환될 수 있다.

### parkNanos(nanos)
```java
public void run() {  
    Logger.log("Start " + Thread.currentThread().getName());  
    LockSupport.parkNanos(2_000_000_000L); // 20억 나노초 = 2초  
    Logger.log("isInterrupted = " + Thread.currentThread().isInterrupted());  
    Logger.log("End " + Thread.currentThread().getName());  
}
```
**LockSupport** 객체는 위와 같이 `park()` 메소드와 비슷한 `parkNanos(nanos)` 메소드를 제공한다. 해당 메소드에 인자로 들어오는 `long` 타입의 데이터는 나노초 단위로써, 호출한 `Thread`를 해당 나노초만큼 `TIME_WAITTING`상태로 변환한다.

### unpark(Thread)
```java
public static void main(String[] args) throws InterruptedException {  
    LockSupportTask task = new LockSupportTask();  
  
    Thread thread1 = new Thread(task, "Thread1");  
    Thread thread2 = new Thread(task, "Thread2");  
  
    thread1.start();  
    thread2.start();  
    Thread.sleep(100);  
    Logger.log("Thread 1 state = " + thread1.getState());  
    Logger.log("Thread 2 state = " + thread2.getState());  
  
    LockSupport.unpark(thread1);  
    thread2.interrupt();  
}
...
private static class LockSupportTask implements Runnable {  
  
    @Override  
    public void run() {  
        Logger.log("Start " + Thread.currentThread().getName());  
        LockSupport.park();  
        Logger.log("isInterrupted = " + Thread.currentThread().isInterrupted());  
        Logger.log("End " + Thread.currentThread().getName());  
    }  
}
```
`unpark(Thread)` 메소드를 호출할 경우, 인자로 주어진 `Thread`를 즉각 `RUNNABLE` 상태로 전환시킨다. 이는 `WAITTING` 상태이던 `Thread`를 다시 전환하여 작업 프로세스를 수행할 수 있도록 도와준다.