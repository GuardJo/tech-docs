> Java Thread의 Interrupt 관련 정리

# 대기 Thread 활성화
`Multi Thread` 환경에서 스케줄링에 의해 `WAITTING` 상태로 전환된 `Thread`나, `sleep()` 메소드 등을 통해 `TIME WAITTING` 상태로 전환된 `Thread`들의 경우, **Context Switching**에 의해 `RUNNABLE` 상태로 변경되거나, 대기 시간이 만료될 경우에만 `RNNABLE` 상태로 전환될 수 있다.

하지만, 일부 요구사항 중 특정 대기 중인 `Thread`를 수동으로 활성화 시키기 위해서, 대기 중인 상태를 활성화 하기 위한 별도의 명령이 필요하다.

# [Thread Interrupt](../ReactiveJava/3.%20Java%20Thread%20Api/Thread%20Interrupt.md)
대기중인 `Thread` 를 활성화 시키기 위해서는 아래와 같이 `Thread`에서 제공하는 `interrupt()` 메소드를 호출하여 대기상태에서 활성상태로 전환 할 수 있다.

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(new WaitTask());

    thread.start();
    Thread.sleep(5000);

    thread.interrupt(); // Interrupt 발생
    thread.isInterrupted(); // True
}

static class WaitTask implements Runnable {
    @Override
    public void run() {
        while (true) {
            try {
                Logger.log("Waiting for task to complete.");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

이는 앞선 **Thread 생명주기**에 따라 대기중인 상태의 `Thread`를 `RUNNABLE` 상태로 전환하기 위한 메소드로써, 대기 시간이나 스케줄링에 관계 없이 호출된 `Thread`를 즉각적으로 `RUNNABLE` 상태로 전환하게 한다.

## InterruptedException
대기 상태의 `Thread` 중 아래와 같이 `sleep()` 메소드 호출 등을 통해 대기 상태가 된 `Thread`는 **Interrupt** 발생 시 예외가 발생하게 된다.

```java
public class Thread implements Runnable {
	...
	public static void sleep(long millis) throws InterruptedException {
		...
	}
}

static class WaitTask implements Runnable {
    @Override
    public void run() {
        while (true) {
            try {
                Logger.log("Waiting for task to complete.");
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

이는 `sleep()` 메소드에서 `InterruptedException`이 발생 가능하다고 정의되어 있으며, 이와 같이 해당 예외가 정의된 메소드를 사용하는 `Thread`가 **Interrupt** 명령을 수신받을 경우, 즉각적으로 `RUNNABLE` 상태로 전환되어 위의 코드를 마저 수행하게 된다.

`Thread`가 **Interrupt** 명령을 수신받을 경우, 즉각적으로 `RUNNABLE` 상태로 전환되어 위의 코드를 마저 수행하게 된다. 이때, 코드 작업 수행 간 `sleep()` 메소드와 같이 `InterruptedException`가 정의된 메소드 호출을 읽을 경우 `InterruptedException` 예외를 던지게 된다.

그렇기에 위와 같은 경우 **Interrupt** 발생을 염두할 경우, `try-catch`를 통해 `InterruptedException` 발생 후 이후 동작을 처리하도록 아래와 같이 작업울 구성할 수 있다.

```java
static class WaitTask implements Runnable {
    @Override
    public void run() {
        try {
            while (true) {
                Logger.log("Waiting for task to complete.");
                Thread.sleep(3000);
            }
        } catch (InterruptedException e) {
            Logger.log("Interrup 발생!");
            Logger.log("state = " + Thread.currentThread().getState()); // state = RUNNABLE
            Logger.log("종료");
        }
    }
}
```

> [!NOTE]
> **InterruptedException 발생 시 interrupt 상태 초기화**
> 
> java의 `Thread` 객체가 `interrup()` 를 통해 **interrupt**가 발생하면, 해당 `Thread`는 `interrupted` 상태로 전환된다. 이후 `RUNNABLE` 상태로 전환된 `Thread` 는 작업을 마저 수행하게 되며, 이 때 `InterruptedException`가 정의되어 있는 메소드 호출 시 `InterruptedException`이 발생하게 되며, 이 때 해당 `Thread`의 `interrupted` 상태는 `false`로 초기화된다.
> 
> 이는, `InterruptedException`이 **Checked Exception**이며, 이에 따라 해당 예외가 발생할 경우, `interrupted` 상태로 넘어간 것을 의미하고, 해당 예외를 처리해야만 프로세스가 비정상 종료되지 않기에 `interrupted` 상태에서의 작업을 처리한 것으로 간주하기 때문이다.