> Java 및 하드웨어에서 제공하는 CAS 연산 정리

# Lock 처리의 단점
Java에선 **Multi Thread** 환경에서의 **동시성 문제**를 해결하기 위해 `synchronized` 키워드를 통한 `Monitor Lock`과 `Lock` 인터페이스를 통한 동기화 처리를 지원한다.

하지만, 이러한 `Lock` 처리 과정에서는 특정 `Thread`가 **임계 영역** 진입 시 `Lock` 획득을 요청하고, 획득 여부에 따라 대기하거나 실행하는 등의 작업들을 수행하여야 하기 때문에, 일반적으로 `Lock` 처리를 위한 추가 작업이 소요된다.

그렇기에 실제 `synchronized` 키워드를 사용하거나 `Lock` 인터페이스를 사용하여 **동시성 문제**를 고려한 작업들은 일반 작업에 비해 소요 시간이 증가하게 된다.

하지만, Java에서 **원자적 연** 작업 등에 사용하는 [`AtomicInteger`](17.%20Atomic%20Calculation.md) 같은 객체들은 **원자적 연산** 작업을 위해 **동시성 문제**를 고려하여 구현되어 있음에도 `synchronized` 나 `Lock` 인터페이스를 사용하는 것보다 작업 속도가 빠르다.

이는 실제 `AtmoicInteger`와 같은 패키지 내 **원자적 연산**을 지원하는 객체에는 `synchronized`나 `Lock` 인터페이스가 아닌 별도의 작업 방식으로 **원자젹 연산** 처리를 보장하기 때문이다.

# CAS 연산
`AtomicInteger`와 같은 **원자적 연산** 처리를 지원하는 객체가 `synchronized`나 `Lock` 인터페이스보다 작업속도가 뛰어난 이유는 **CAS 연산** 작업으로 작업을 처리하기 때문이다.

**CAS 연산** 이란 **CompareAndSet**의 약자로 연산 작업 요청 시 현재 저장된 값에 대한 검증 여부에 따라 연산을 처리하거나 처리하지 않도록 하는 연산 작업이다.

```java
AtomicInteger atomicInteger = new AtomicInteger();

boolean result = atomicInteger.compareAndSet(0, 1); // 현재 값이 0이면 1을 더한다.
```

Java의 `AtomicInteger`의 경우 위와 같이 `compareAndSet()` 메소드를 지원하며, 이를 통해 첫 번째 인자의 값이 현재 값과 동일할 경우 두 번째 인자의 값을 연산하도록 하며, 이에 따른 `boolean` 값을 반환한다.

## CAS의 원자적 연산
현재 값을 비교하여, 결과에 따라 값을 처리하는 **CAS 연산** 방식의 경우, 처리 방식만 봐도 **원자적 연산** 과는 거리가 멀어 보인다.

하지만, **CAS 연산**은 특수한 경우로써, **CAS 연산** 처리의 경우 대부분의 환경에서 `AtomicInteger`와 같은 작은 단위의 **CAS 연산** 처리 시 **원자적 연산** 을 보장하기 때문이다.

이는, 단순 Java를 포함한 애플리케이션 레벨이 아닌 CPU 및 하드웨어 레벨에서 값을 비교하고, 비교한 값에 따라 이후 값을 계산하는 방식이 CPU 레벨에서 일괄적으로 처리되도록 **CAS 연산**을 지원하기 때문이다.
- *실제 CPU 입장에선 단순 값에 대한 **CAS 연산** 처리는 극히 찰나의 순간에 처리할 수 있기 때문임*