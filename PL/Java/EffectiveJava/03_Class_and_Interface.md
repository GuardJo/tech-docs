> Effective Java 관련 학습 : 클래스와 인터페이스

# 1. 클래스와 멤버의 접근 권한을 최소화하라
효율적인 객체지향 설계 관점에서는 외부에 제공하는 객체의 요소들은 최소화 하는 것이 좋다.

사용자 입장에서는 명확하게 필요한 API들만을 식별할 수 있기에 좋으며, 개발자 입장에서는 외부에 공개되는 API, 메소드들을 제외한 나머지 요소들은 내부에서 수정하기 용이하며, 외부에 관리해야할 요소들을 줄일 수 있다.
- *이는 정보 은닉, 캡슐화의 한 맥락으로 볼 수 있다.*

## 1-1. 정보 은닉
Java에서는 위와 같은 요소를 제공하기 위해 클래스, 메소드, 필드 등에 접근 제한을 지정할 수 있다.

외부 사용자에게 노출해야할 요소들은 `public` 하게 선언해 모든 사용자가 접근할 수 있게 하며, 이외에는 접근할 수 없도록 `private`, `protected` 등으로 제한한다.

### 1-1-1. 접근 제한자
`public`
- 외부 모든 곳에서 접근 가능한 요소

`package-pivate`
- 해당 패키지와 동일한 패키지 내에서만 접근 가능한 요소

`protected`
- 해당 패키지와 동일한 패키지 및 해당 요소의 하위 요소까지 접근 가능

`private`
- 해당 객체 내에서만 접근 가능

## 1-2. public 클래스의 필드 접근 제한
`public` 접근 제한자로 외부 모든 요소에서 접근할 수 있도록 풀려 있는 class 에서는 내부 인스턴스 필드들의 접근 제한을 최대한 제한해야 한다.

만약 내부 필드들도 `public` 하게 공개되어 있을 경우, 누구나 해당 필드를 수정할 수 있기에 클래스 입장에서 해당 필드들에 대한 제어권을 잃게 된다.
- *또한 배열 객체의 경우 크기가 0이 아니면 `final`필드여도 수정이 가능하기에 주의해야 한다*

> [!NOTE]
> **Java Module System**
> 
> java 9 에서 추가된 모듈 시스템은 패키지들을 묶는 단위로 볼 수 있으며, 모듈에 포함된 요소들은 모듈의 설정에 따라 외부에 공개 여부를 지정할 수 있다.
> 
> 이를 통해 `public`으로 지정된 요소여도 모듈의 설정에 따라 외부에는 공개되지 않을 수도 있다.

# 2. public 클래스에서는 public 필드가 아닌 접근자 메소드를 사용하라
Java에서 `public` 클래스로 외부에서 접근할 수 있도록 개방된 class 내에는 `public`으로 선언된 필드를 구성하지 않는 것이 좋다.

이미 class 자체가 제한 없이 접근할 수 있는 상태에서 필드마저 제한 없이 접근할 수 있으면, 해당 필드를 사용자가 임의르 수정 할 수 있게 되며, 그에 따라 비정상적인 동작이 이루어질 수 있다.
 - *또한 class 입장에서 해당 필드에 대한 제어를 완전히 잃게 된다*

그렇기에 주로 `public` 클래스 내 필드들은 `private` 등의 제한된 접근 방식으로 구성하여 필드 자체에 직접 접근하지 못하게 하는 대신 getter() 와 같은 접근자 메소드를 `public` 하게 선언되어 조회는 누구나 가능하게끔 제공할 수 있다.

위와 같이 `public`한 접근 메소드를 제공함으로써 외부에서는 특정 필드에 대한 데이터를 얻을 수 있으며, class 자체에서는 필드를 수정함에 있어서 보다 간편히 수정할 수 있게 된다.
- *getter() 메소드에 대한 응답 데이터만 일관화 하면 되기 때문*
# 3. 변경 가능성을 최소화 하라
외부에서 접근할 수 있도록 한 `public`한 class들의 경우 내부 필드가 최대한 수정이 되지 않는 상수여야, 사용자 입장에서도 늘 같은 값을 기대할 수 있으며, 개발자 입장에서도 고려해야될 오류를 줄일 수 있다.

불변 객체의 경우, 언어 레벨에서 이미 해당 데이터의 값이 변경될 수 없음을 보장하기에, 여러 쓰레드에서 해당 필드를 사용하더라도 문제가 되지 않으며, 잠시라도 정합성이 깨질 일이 없다는 장점이 있다.

단, 불변 객체에도 단점이 있는데, 불변을 유지하기 위해 여러 연유로 다른 값으로 변경이 필요할 경우, 값마다 별도의 객체를 신규로 생성해야 한다.
- *이는 작은 단위면 문제 없으나 객체 생성에 큰 자원이 소모되는 요소들의 경우, 성능 상 단점으로 부각될 수 있음*

위와 같은 단점을 보완하고자 불변 객체와 쌍을 이루는 가변 연산 처리를 도와주는 객체들도 존재한다
- *ex) 불변 객체인 `String`의 연산 작업 등을 위한 `StringBuilder`가 대표적*

## 3-1. 불변 객체 생성 규칙
1. 불변 객체는 상태를 변경할 수 있는 메소드를 외부에 제공하지 않는다.
	setter() 와 같이 필드 값을 수정할 수 있는 메소드를 구성하지 않음
2. 클래스를 확장할 수 없도록 한다.
	확장한 클래스가 기존 필드를 재정의할 수 없게끔, 생성자에 대한 접근을 제한하여 확장 할 수 없도록 함
3. 모든 필드를 final 키워드로 생성한다.
	`final` 키워드로 사용함으로써 불변임을 명시함
4. 모든 필드를 private 키워드로 생성한다.
	`private` 키워드로 생성함으로써 외부에서 접근할 수 없도록 막음
# 4. 상속보다는 컴포지션을 활용하라
Java에서는 객체 지향 프로그래밍의 강력한 요소 중 하나인 상속을 지원한다.

허나 상속은 들여다보면 객체지향의 장점 중 하나인 캡슐화를 위배하게 된다.

이는 상속을 함으로써 상위 객체의 모든 요소들을 재정의할 수 있기 때문이며, 상속관계로 묶이게 되면서 상위 객체가 수정될 경우 하위 객체의 수정이 불가피하기 때문이다.

상속할 객체가 이러한 문제나 이슈들을 잘 정리해두었으면 그나마 덜하겠지만 그것이 아닌 경우, 상위 객체의 알지 못햇던 내부 동작에 따라 하위 객체에서 재정의한 요소를 호출 할 경우 문제가 발생한다.

이러한 상속의 단점을 보완하기 위해 컴포지션(Compisition)이라는 객체 구성 방법이 존재한다.

컴포지션은 필요한 객체를 상속하지 않고 `private`으로 선언한 내부 필드로 참조하여 기본 요소들을 해당 필드의 메소드 호출을 통해 구성하며 추가 구현이 필요한 부분만 현 객체에 구현하는 것이다.

이러한 방법을 통해 상속과는 달리 참조하는 객체의 기능 흐름에는 관여하지 않으면서 필요가 기능들을 활용할 수 있으며, 참조 객체가 수정되더라도 현 객체에는 별다른 side effect가 발생하지 않는다.
> [!NOTE]
> 상속을 구성해야할 때에는 하위 객체가 반드시 상위 객체의 하위 타입으로 구성되어야 할 필요가 있는지 식별해야 한다.
> 
> 만약 그렇지 않다면 컴포지션으로 구성하는 것이 객체지향 관점에도 알맞으며, 유지 보수 측면에서도 이롭다.
# 5. 상속을 고려해 설계하고 문서화하라, 그러지 않았다면 상속을 금지하라
앞서 상속을 함으로써 객체 지향 관점에서의 캡슐화 및 정보 은닉 등의 차원에서 단점이 부각되었으며, 이를 통해 상속보다는 컴포지션을 활용하는 것이 좋다고 언급하였다.

허나 부득이하게 상속을 해야 할 경우에는 상속이 필요한 class에 대해 상속했을 때의 발생할 수 있는 문제점, 외부에 공개된 API 메소드의 실행흐름 등을 문서화해야 한다.
그렇게 함으로써 그나마 상속하여 하위 객체를 구성할 때 관련된 점을 참고 하여 구현할 수 있기 때문이다.
- *본디 주석은 실행 흐름이 아닌 해당 메소드가 무엇을 반환하는지 등을 명시해야 하나, 상속의 단점을 보완하기 위해서는 어쩔 수 없이 실행흐름을 명시해야 한다.*

또한, 상속을 고려하여 객체를 구성하였을 경우에는 생성자에서 재정의 가능한 메소드를 호출해서는 안된다.
Java에서는 하위 객체의 생성자보다 상위 객체의 생성자를 우선적으로 호출하며, 만약 이때 하위 객체에서 재정의된 함수를 호출할 경우 해당 함수는 아직 하위객체 생성자도 진입하지 못한 상태이므로 예기치 못한 오류가 발생할 수 있다.
- *Cloneable, Serializable 구현체도 생성자와 마찬가지의 주의가 필요하다.*
# 6. 추상클래스 보다는 인터페이스를 우선하라
Java에서는 하나의 메소드를 여러 객체에서 구현하거나 재정의할 수 있도록 `Abstract Class`와 `Interface` 객체를 제공한다.

기존에는 `Interface`는 별도로 구현된 메소드를 지닐 수 없었으나 java 8부터 `default method`를 구현할 수 있게 되면서 더욱이 상속보다 더 우선시 되는 요소가 되었다.

이는 앞서 설명한 상속의 단점과 이어지는데, 특정 객체를 `Abstract Class`를 상속하여 구현할 경우 해당 객체는 상위 객체에 종속적일 수밖에 없게 된다.
그에 반해 `Interface`에 대한 구현체로 만들 경우 요구하는 메소드만 추가하면 된다.
- *하나의 객체는 하나의 `Abstract class`만 상속받을 수 있으나 `Interface`는 제한 없이 상속 받을 수 있음*

또한 `Interface`는 `Abstract Class`와 다르게 비계층적으로 구조를 구성할 수 있다.

```java
public interface Singer {
	AudioClip sing(String s);
}
...
public interface Songwriter {
	Song compose(int chartPosition);
}
```

만약 위와  같은 `Interface`를 `Abstract Class`로 구현 했을 경우 위 요소들을 상속 받는 하위 객체는 `Singer`이거나 `Songwriter` 이거나 둘 중 하나만 받을 수 있게 되고 둘 모두를 동일한 레벨로 구현할 수 없지만, `Interface`의 경우 아래와 같이 둘 모두를 상속할 수도 있게 되어, 비계층적으로 구현 할 수도 있다.

```java
public interface SingerSongwriter extends Singer, Songwriter {
	AudioClip sing(String s);
	Song compose(int chartPosition);
}
```

위와 같이 `Abstract Class`에 비해 `Interface`는 객체 상속 간에 보다 자유롭게 상속하여 구조를 구성할 수 있다.

> [!NOTE]
> **추상 골격 구현 : Template Method Pattern**
> 
> `Interface`와 `Abstract class`의 장점을 합친 구조로써, `Interface`를 통해 타입이 정의된 메소드들과 일부 공통 기능이 담긴 default method 들을 `Abstract class` 에 상속하여 타 메소드들을 구현하고 이러한 `Abstract Class`를 확장하는 것으로써 `Interface` 구현에 필요한 대부분의 요소를 만족하게 된다.

# 7. 인터페이스는 구현하는 쪽을 생각해 설계하라
Java 8 이전의  `Interface` 객체는 기존 구현체들을 깨뜨리지 않고는 별도의 메소드를 추가할 수 없었다. 허나 Java 8부터 `Interface`에 default method 추가가 가능해짐에 따라 기존 구현체를 유지하면서 `Interface` 객체에 신규 메소드를 추가할 수 있게 되었다.

이러한 점은 Java 8 이전에 구현된 관련 구현체들에 심각한 타격을 줄 수 있는데, `Interface`객체를 컴파일 할 때에는 문제가 안되지만 해당 `Inteface` 구현체의 경우에는 어떠한 Side Effect가 발생할 지 알 수 없다.
- *그도 그럴 것이 해당 구현체들은 자신이 사용하는 `Interface`에 신규 메소드가 추가될 것을 고려하지 않았기 때문임*

결국 `Interface`를 구현할 때에는 이처럼 해당 객체를 기반으로 구현체를 구현하는 쪽의 부분도 신경써야 한다.

# 8. 인터페이스는 타입을 정의하는 용도로만 사용하라
Java에서 `Interface`의 역할은 어디까지나, 해당 `Interface`를 구현한 객체의 인스턴스가 어떤 타입의 `Interface`인지 명확히 하는 용도이며 해당 구현체가 어떠한 역할을 수행할 수 있는지 명시한것이라고 볼 수 있다.

종종 아래와 같이 이러한 `Interface`의 사용 용도와 맞지 않게 아래처럼 구성하는 경우가 있다.

```java
public interface PhysicalConstants {
	final static double PIE = 3.141_592;
	...
}
```

위와 같이 그저 몇몇 객체에서 사용하기 위한 상수들을 `Interface`로 묶어서 상속하여 사용하는 경우가 있는데, 이는 `Interface`를 잘못 설계한 경우이다. 위와 같이 사용하려면 `Interface`가 아니라 아래와 같이 별도 유틸리티 객체로 구성하는 것이 옳다.

```java
public class PhysicalConstants {
	private PhysicalConstants() {} // 인스턴스 생성 불가하도록 구성

	public final static double PIE = 3.141_592;
}
```

>[!NOTE]
> Java 9 부터는 숫자 리터럴에 `_` 를 사용함으로써 보다 가독성을 높여줄 수 있다.
> 

# 9. 태그 달린 클래스보다는 클래스 계층 구조를 활용하라
아래와 같이 사용하는 경우는 거의 없겠지만, 예를 들어 아래와 같이 태그(Shape) 를 통해 인스턴스를 구별하여 동작을 수행하는 요소가 있다고 한다.

```java
class Figure {
	enum Shape { RECTANGLE, CIRCLE };

	// 태그 필드
	final Shape shape;
	// Rectangle에만 필요한 필드
	double length;
	double width;
	// Circle에만 필요한 필드
	double radius;

	// Circle 용 생성자
	// Rectangle 용 생성자

	public double area() {
		switch(shape) {
			case RECTANGLE : 
				return length * width;
			case CIRCLE : 
				return Math.PI * (radius * radius);
			default :
				...
		}
	}
}
```

위와 같이 하나의 객체에서 태그 필드(Shape)에 따라 내부적인 로직이 다를 경우, 해당 객체는 사용하지 않는 필드들에 대한 불필요한 초기화 작업 및, 해당 태그 별 값 반환을 위해 불필요한 분기 작업 등을 거쳐야 한다.

이러한 구조는 매우 비효울적인 구조이며, 사용자 실수로 에러가 발생하기 쉽다. 이런 경우에는 주로 공통 부분읠 `Abstract Class`로 구현한 후 해당 객체를 상속 받아 여러 타입으로 구성하는 것이 보다 바람직 하다.

```java
abstract class Figure {
	abstract double area();
}
...
class Circle extends Figure {
	...
}
...
class Rectangle extends Figure {
...
}
```

위와 같이 `Abstract Class`로 Figure 객체를 구성한 후 공통적으로 필요한 `area()`함수만을 구성해둔 후 Circle과 Rectangle 등 각각 개별적으로 필요한 필드들은 해당 객체에서 선언하면, 앞선 태그를 사용하는 방식보다 훨씬 효율적으로 코드를 구성할 수 있으며, 사용자 실수도 줄일 수 있다.
- *또한 이렇게 구성함으로써 향후 다른 도형 객체들로 확장하기도 용이함*
# 10. 멤버 클래스는 되도록 static으로 만들라
Java에서는 `Class` 내에 또 다른 `Class`를 생성할 수 있다. 이러한 `Class`를 `Nested Class`, 중첩 클래스라고 한다.

중첩 클래스의 경우 크게 아래 4경우로 구분된다.
- 정적 멤버 클래스
- 비정적 멤버 클래스
- 익명 클래스
- 지역 클래스

## 10-1. 정적 멤버 클래스
정적 멤버 클래스는 해당 클래스의 바깥 클래스에 필요한 요소들을 별도 객체로 구성할 필요가 있을 때 구현한다.

```java
class Parent {
	void print() {
		System.out.println(ParentPrinter.LOG_FORMAT + "hello?");
	}

	private static class ParentPrinter {
		final static String LOG_FORMAT = "log : ";
		...
	}
}
```

위와 같이 일반적으로 정적 멤버 클래스는 로직 수행 간에 바깥 클래스와의 참조 등이 필요하지 않은 독립적인 형태로 구현이 가능하다.

## 10-2. 비정적 멤버 클래스
정적 멤버 클래스와 다르게 해당 클래스는 바깥 클래스에 일부 종속적인 요소를 기능에 포함하고 있다.

```java
public class MySet<E> extends AbstractSet<E> {
	...
	@Override
	public Iterator<E> iterator() {
		return new MyIterator();
	}
	...
	private class MyIterator implements Iterator<E> {
		...
	}
}
```

그렇기에 해당 클래스를 사용하기 위해서는 바깥 클래스에서 초기화 작업이 필요하며 이에 따라, 해당 클래스와 참조 관계가 구성된다.
- *static을 생략하여 비정적 멤버 클래스로 구성할 경우 바깥 인스턴스로부터의 숨은 참조가 발생하여 해당 공간 만큼 자원을 추가로 소모하게 됨*
- *또한 비정적 멤버 클래스가 참조를 지니고 있기에 바깥 클래스가 GC에 의한 제거가 불가해지는 경우도 발생함.*

## 10-3. 익명 클래스
익명 클래스는 앞선 멤버 클래스들과는 다르게 쓰이는 시점에 즉각적으로 인스턴스가 생성되고 작업을 수행한다.

```java
public class Parent {
	public void test() {
		System.out.println("Test : " + new AnonymousClass() {
			@Override
			public String toString() {
				"익명 클래스";
			}
		});
	}
}
```

위와 같이 작업 수행 간에 일회성으로 작업이 필요한 경우에 주로 사용된다.
- *java 8 이후에는 람다가 지원되면서 해당 요소를 대체하게 됨.*

## 10-4. 지역 클래스
지역 변수가 선언되는 모든 부분에 선언될 수 있는 클래스

```java
void print() {
	class Printer {
		...
	}
	...
}
```

특정 메소드 내에서만 사용할 클래스들을 선언하여 사용한다.

> [!NOTE]
> Nested Class는 바깥 클래스와의 관계가 필요하지 않는 경우에는 왠만하면 정적 멤버 클래스로 생성하는 것이 메모리 관리 및  효율성 측면에서 이롭다.
> 
> 비정적 멤버 클래스의 경우에는 각각의 인스턴스가 바깥 인스턴스를 참조하기에 그만큼 메모리를 사용하며 생성 및 제거 시에 관련 작업들에 리소스를 사용하기 때문이다.
