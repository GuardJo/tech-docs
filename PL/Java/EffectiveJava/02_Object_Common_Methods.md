> Effective Java 관련 학습 : 모든 객체의 공통 메소드

# 1. equals는 일반 규약을 지켜 재정의하라
두 객체 인스턴스가 동일한지 여부를 판단하기 위해 사용되는 equals() 메소드는 Java 최상단 객체인 Object에 정의된 메소드이다.

final이 아닌 메소드이기에 누구나 Override할 수 있으며, 이 때 `equals()` 메소드의 기본 규약을 지켜 Overriding 해야 한다.
- 이는 Object의 `equals()`가 규약대로 구현되어 있다는 가정하에 Collection이나 일부 다른 객체들이 구현되어 있기 때문이다.

## 1-1. equals 기본 규약
`equals()`는 동치 관계 (Equivalence relation)을 구현하며, 이를 위해 아래와 같은 사항을 만족해야 한다.
1. **Reflexivity (반사성)**
	null이 아닌 모든 참조 값 x 에 대해 x.equals(x) 가 true여야 함
2. **Symmetry (대칭성)**
	null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면 y.equals(x) 도 true여야 함
3. **Transitivity (추이성)**
	null 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true, y.equals(z)도 true이면 x.equals(z)도 true여야 함
4. **Consistency (일관성)**
	null 아닌 모든 참조 값 x, y에 대해 x.equals(y)를 반복해서 호출해도 항상 True이거나 False 여야 함
5. **Not-null (null 아님)**
	null 아닌 모든 참조 값 x에 대해 x.equals(null)은 false 여야 함

> [!NOTE]
> **equals() 재정의**
> 
> 일반적으로 대부분의 객체는 `equals()`를 재정의할 필요가 없다. 이미 대부분의 객체가 기존 요소로 충분하기 때문이다. 그러나, 일부 값 객체 (DTO 등)에서는 논리적인 값 동치 작업이 필요하기에 그런 시점에선 `equals()`를 재정의하여 사용한다.

# 2. equals를 재정의하려거든 hashCode도 재정의하라
Java에서는 `equals()` 메소드를 재정의 했을 경우, 필수적으로 `hashCode()`도 재정의 해주어야 한다.
이를 재정의하지 않았을 경우 hash 값을 사용하는 `HashMap`, `HashSet` 등을 사용할 때 문제가 발생할 수 있다.

`hashCode()`는 두 객체가 논리적으로 동치 (`equals())하다면 `hashCode()`의 반환값도 동일해야 한다.

이에 따라 `hashCode()`는 동일한 객체에서도 인스턴스가 서로 다르다고 판단되면 다른 값을 반환할 수 있도록 해야하며, 인스턴스가 동일하면 동일한 값을 반환할 수 있도록 구현해야 한다.

# 3. toString을 항상 재정의하라
Java의 가장 최상단 객체인 Object에서 제공하는 메소드 중 `toString()`메소드는 사용자가 직접 호출하지 않더라도 다양한 곳에서 내부적으로 호출된다.
- *ex) print(), 문자열 연결 연산자( + ), assert 등*

그렇기에 상위 객체에서 `toString()` 이미 재정의 한 것이 아니라면, 대부분의 신규 구현한 객체에는 `toString()` 재정의 해주는 것이 좋다.

`toString()`을 재정의 함으로써 디버깅이나 출력 등에서 보다 이해하기 쉽게 파악이 가능하며, 해당 객체가 어떠한 정보들로 이루어져 있는지도 보여줄 수 있다.

# 4. Clone 재정의는 주의해서 진행하라
Java의 최상단 객체인 Object 객체에는 재정의할 수 있는 메소드들 중에 `clone()` 메소드를 제공한다.
이름에서부터 알 수 있듯이 특정 객체를 복제하기 위해 호출되는 함수이나 독립적으로 쓰이진 않고 `Cloneable` 인터페이스의 구현체가 `clone()` 메소드에 대한 동작 방식을 결정한다.
- *허나 이는 인터페이스를 일반적이지 않게 사용하는 것으로, 인터페이스 구현체가 상위 객체 (Object) 에 `private`으로 선언된 함수의 기능에 대한 결정권자가 되버림*
	- 그렇기에 실무에서는 Cloneable 구현체의 경우 `clone()` 을 `public`으로 구성함

## 4-1. Clone() 명세
`clone()` 메소드는 Java 명세에서 아래와 같은 요소들을 기반으로 한다.
1. x.clone() != x
	특정 객체를 복제하였을 경우 실제 인스턴스는 달라야함
2. x.clone().getClass() == x.getClass()
	특정 객체를 복제하였더라도 각 객체의 타입을 같아야함
3. x.clone().equals(x) ?
	해당 식은 참일 수도 아닐 수도 있음 (`불명확한 명세`)

위와 같은 관례에 따라 특정 객체를 `clone()` 호출을 통해 복제할 경우, 객체 타입은 동일할 수 있으나 인스턴스는 다르게 구성될 수도 있다.
- *같은 타입의 다른 인스턴스를 반환해야 한다는 점에서 생성자랑 비슷하다고 볼 수 있음*

이에 대해 `clone()` 함수를 재정의해야할 경우에는 가변 필드들에 대한 동치 여부 등을 순회하면서 확인 및 신규 인스턴스에 주입해주어야 한다.
- *허나 일부 필드가 `final`로 지정되어 있을 경우, 풀어서 주입해줘야하는 경우도 생길 수 있음*

결국 위의 제한 사항 및 불확실한 명세에 따라 `clone()`을 재정의하는 것은 부담스러우며, 이 대신 복사 생성자나 복사 팩토리 메소드를 사용하는 것이 더욱 효율적이다.

> [!NOTE]
> **복사 생성자, 복사 팩토리 메소드**
> 
> 특정 객체 내 동일한 필드 값들을 지닌 객체를 반환하기 위해 생성자 혹은 팩토리메소드로 본인과 같은 타입의 객체를 인자로 받아 신규 인스턴스를 생성함으로써 복제 작업을 수행할 수 있다.

# 5. Comparable 을 구현할지 고려하라
 Java에서는 두 객체 사이의 순서 비교를 위한 각종 인터페이스 및 객체들을 사용하기 위해서는 비교하려는 객체가 `Comparable` 인터페이스에 대한 구현체여야 한다.

`Comparable` 인터페이스는 내부에 `compareTo()` 함수만을 지니고 있으며, 이에 대한 기능을 구현함으로써 정렬 등의 기능이 담긴 객체를 정상적으로 사용할 수 있다.

`compareTo()` 는 기본적으로 `equals()` 와 같은 동치 기능에 더해, 두 객체간의 차이에 따라 현재 객체가 입력받은 객체보다 작은 경우에는 음수, 같은 경우에는 0, 보다 큰 경우에는 양수를 반환하도록 정의되어 있다.

## 5-1. compareTo() 명세
`compareTo()`가 정상적으로 수행되기 위해서는 아래와 같은 명세로 구현되어야 한다.
1. 두 비교 객체의 순서를 바꿔 비교해도 동일한 결과가 나와야 한다. `(반사성)`
	*첫번째 객체에 두번째 객체를 비교했을때 음수가 나오면, 반대로 두번째 객체에 첫번째 객체
	를 비교했을 땐 양수가 나와야 됨*
2. 첫번째 객체가 두번째 객체보다 크고 두번재 객체가 세번째 객체보다 크다면 첫번째 객체는 세번째 객체보다 커야 한다. `(대칭성)`
3. 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 같아야 한다. `(추이성)`

결국 `equals()`와 마찬가지로 반사성, 추이성, 대칭성 등을 준수해야 하며, 추가적으로 대부분의 정렬 기능이 포함된 인터페이스들은 `compareTo()`를 통해 정렬된 결과와 `equals()`를 통해 비교한 결과가 동일하길 기대하기에 두 함수 사이의 동치성 기능이 같아야 한다.

또한 `compareTo()`를 구현할 때에는 비교에 필요한 필드가 다수인 경우, 자체적인 우선순위를 정하여 양수 혹은 음수의 나오도록 순위대로 탐색해야 한다.
- *이러한 다수의 필드에 대한 compare 작업 처리 지원을 위해 Java에서는 `Comparator` 인터페이스를 제공한다.*
	- `Comparator` 인터페이스에는 수 비교, 객체 비교 등 다양한 상황에 대비된 함수들이 구성되어 있음

>[!NOTE]
> 값 비교 연산자 처리 시, Java 7 이전에는 연산자 기호를 사용하였으나, 이후 버전부터는 기본타입 각각의 Wrapper 타입에 비교 관련된 정적 메소드들을 제공한다.
> 
> - ex) `Integer.compare(1, 2);`

