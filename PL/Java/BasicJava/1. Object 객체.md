> Java의 최상위 객체

# Object
객체지향 프로그래밍 언어인 Java에서 모든 객체 (Class)의 최상위 객체로서 대부분의 객체에서 필요한 기본적인 메소드들을 포함하고 있다.

## Object 구조
```java
class Object {
	...
	public final native Class<?> getClass();
	...
	public boolean equals(Object obj) {
		...
	}
	...
	public String toString() {
		...
	}
	...
}
```

## Object 특징
Java에서 제공하는 모든 객체 및 사용자 생성 객체들의 경우 별도의 상속관계를 명시하지 않은 객체들은 전부 Object 객체를 묵시적으로 상속한다.
- 명시적으로 상속관계를 구성한 객체의 경우에도 최종적으로 상속 관계가 명시적으로 구성되지 않은 객체를 기준으로 `Object`객체를 상속받음

> [!NOTE]
> Java에서는 이러한 Object 객체를 모든 객체가 상속 받고 있기에, 객체 간 비교, 객체 정보 반환 등 일반적으로 필요한 기능들을 별도의 구현 없이 호출 할 수 있다.

# Object 다형성
Object 객체의 경우 모든 객체의 상위 객체이기에 여러 타입의 객체를 하나의 필드에 매핑하거나 인자로 받기 위해 아래와 같이 활용할 수 있다.
## Object 필드 매핑
```java
public class Storage {  
    public Object item;  
}
...
public class ItemExecutor {  
    public void execute() {  
        Storage storage = new Storage();  
        Car car = new Car();  
        Person person = new Person();  
  
        storage.item = person;  
        storage.item = car;  
    }  
}
```

위와 같이 여러 타입의 객체를 하나의 필드에 매핑하기 위해 최상위 객체인 Object를 필드타입으로 지정하여 모든 하위 객체들을 매핑할 수 있게 구성할 수 있다.

## 메소드 인자로 받기
```java
public class Main {  
    public static void main(String[] args) {  
        Car car = new Car();  
        Person person = new Person();  
  
        move(car);  
        move(person);  
    }  
  
    public static void move(Object obj) {  
		...
    }  
}
```

위와 같이 메소드 인자로 받아와 여러 타입의 객체를 인자로 받아올 수 있도로 제공할 수 있다.

### Object 다형성 주의점
앞서 예시로 들었던 Car, Person 객체의 경우 별도의 메소드들이 선언되어 있으나, Object 객체로 매핑할 경우 해당 메소드들을 사용할 수 없다.

이는 비록 각 객체가 생성 시점엔 Car, Person 객체이지만, Object 객체로 매핑하는 순간 Object 객체로 인식하여, Object 객체에 선언된 메소드들만 사용할 수 있기 때문이다.

그렇기에, 만약 다형성을 통해 Object 객체로 매핑 후 각 객체의 메소드를 사용하기 위해서는 아래와 같이 `다운캐스트`하여 사용해야 한다.

```java
public static void move(Object obj) {  
    if (obj instanceof Person person) {  
        System.out.println(person.move());  
    } else if (obj instanceof Car car) {  
        System.out.println(car.drive());  
    }  
}
```

# Object 배열
Object가 Java에서 제공하는 최상위 객체이므로, 어떠한 타입의 값도 담을 수 있는 배열 객체를 구성할 수 있다.

```java
public void execute() {  
    Car car = new Car();  
    Person person = new Person();
    int number = 111;
  
    Object[] objects = {car, person, number};  
  
    System.out.println("Size : " + objects.length);  
}
```

위와 같이 Object 객체를 활용하면, 각 Car, Person 등 사용자 생성 타입과 Java에서 기본 제공하는 타입 등 다양한 타입을 하나의 배열에 삽입할 수 있다.

# toString()
Object 객체에서 기본적으로 제공하는 메소드 중 하나로 기본 제공 사항은 해당 객체에 대한 Class 타입과 참조 값을 문자열로 반환한다.

```java
public String toString() {  
    return getClass().getName() + "@" + Integer.toHexString(hashCode());  
}
```

위와 같이 Class 명과 `hashCode()` 메소드를 통해 출력된 참조값을 반환해준다.

## 객체 출력 시 toString() 출력
```java
Car car = new Car();  
Person person = new Person();  
Object object = new Object();  
  
System.out.println(car);  
System.out.println(person);  
System.out.println(object);
```

위와 같이 `println()` 등의 메소드 호출을 통해 객체를 출력할 경우 내부적으로 해당 객체 내 `toString()` 메소드를 요청하여 값을 출력하게 된다.

이에 따라, Java 내 기본 제공 객체 및 사용자 생성 객체들은 아래와 같이 `toString()` 메소드를 `override`하여 해당 객체 내 출력 정보 들을 원하는 형태로 구성할 수 있다.

```java
public class Person {  
    private final String name;  
  
    ....
    
    @Override  
    public String toString() {  
        return "Person{" +  
                "name='" + name + '\'' +  
                '}';  
    }  
}
```

> [!NOTE]
> `println()` 과 같이 내부적으로 `toString()`을 호출 할 때에는 Object 객체의 `toString()`을 요청할 시점에 자식 객체 내 `toString()`이 재정의 되어 있을 경우 해당 메소드를 호출하게 된다.

### System.identityHashCode()
만약 `toString()` 메소드나 `hashCode()` 메소드를 재정의한 객체는 참조값을 즉각적으로 반환받기 어렵다.
그렇기에 Java 에서는 이러한 객체들에 참조값을 반환받기 위해 System 객체 내 static 메소드로 `identityHashCode()` 메소드를 제공한다.

```java
String refValue = Integer.toHexString(System.identityHashCode(person));  
System.out.println(refValue);
```

위와 같이 `identityHashCode()` 메소드를 사용하여 해당 객체의 참조값을 반환 받을 수 있다.